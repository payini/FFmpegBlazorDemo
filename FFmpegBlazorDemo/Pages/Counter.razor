@page "/concatenate"
@using FFmpegBlazor
@inject IJSRuntime Runtime
@using Microsoft.AspNetCore.Components.Forms

<PageTitle>Concatenate Videos</PageTitle>

<h1>Concatenate Videos</h1>

<InputFile OnChange="fileLoad1" />
<br />
<br />
<video width="300" height="200" autoplay controls src="@videoInputUrl1" />
<br />
<br />
<InputFile OnChange="fileLoad2" />
<br />
<br />
<video width="300" height="200" autoplay controls src="@videoInputUrl2" />
<br />
<br />
<button class="btn btn-primary" @onclick="Process">Concatenate Videos</button>
<br />
<br />
<audio controls src="@audioOutputUrl" />
@*<video width="300" height="200" autoplay controls src="@audioOutputUrl" />*@

<br />
<br />
<video width="300" height="200" autoplay controls src="@videoOutputUrl" />
<br />
<br />

@code
{
    string videoInputUrl1;
    string videoInputUrl2;
    string videoOutputUrl;
    string audioOutputUrl;
    FFMPEG ff;
    byte[] buffer1;
    byte[] buffer2;

    protected override async Task OnInitializedAsync()
    {
        if (FFmpegFactory.Runtime == null)
        {
            FFmpegFactory.Logger += WriteLogs;
            FFmpegFactory.Progress += ProgressChange;
        }

        //initialize Library
        await FFmpegFactory.Init(Runtime);
    }

    async void fileLoad1(InputFileChangeEventArgs v)
    {
        //get fist file from input selection
        var file = v.GetMultipleFiles()[0];

        //read all bytes
        using var stream = file.OpenReadStream(100000000); //Max size for file that can be read
        buffer1 = new byte[file.Size];

        //read all bytes
        await stream.ReadAsync(buffer1);

        //create a video link from buffer so that video can be played
        videoInputUrl1 = FFmpegFactory.CreateURLFromBuffer(buffer1, "videoInput1.mp4", file.ContentType);

        //reRender DOM
        StateHasChanged();
    }


    async void fileLoad2(InputFileChangeEventArgs v)
    {
        //get fist file from input selection
        var file = v.GetMultipleFiles()[0];

        //read all bytes
        using var stream = file.OpenReadStream(100000000); //Max size for file that can be read
        buffer2 = new byte[file.Size];

        //read all bytes
        await stream.ReadAsync(buffer2);

        //create a video link from buffer so that video can be played
        videoInputUrl2 = FFmpegFactory.CreateURLFromBuffer(buffer2, "videoInput2.mp4", file.ContentType);

        //reRender DOM
        StateHasChanged();
    }

    async void Process()
    {
        //create an instance
        ff = FFmpegFactory.CreateFFmpeg(new FFmpegConfig() { Log = true });

        //download all dependencies from cdn
        await ff.Load();

        if (!ff.IsLoaded) return;

        //write buffer to in-memory files (special emscripten files, Ffmpeg only interact with this file)
        //ff.WriteFile("test.mp4", buffer1.Concat(buffer2).ToArray());

        ff.WriteFile("videoInput1.mp4", buffer1);
        ff.WriteFile("videoInput2.mp4", buffer2);

        //Pass CLI argument here equivalent to ffmpeg -i myFile.mp4 output.mp3
        await ff.Run("-i", "videoInput1.mp4", "-i", "videoInput2.mp4", "-filter_complex", "concat=n=2:v=1:a=0", "-vn", "-y", "output.mp4");
        //await ff.Run("-i", "videoInput1.mp4", "-s", "20x80", "output.mp4");

        //delete in-memory file
        //ff.UnlinkFile("myFile.mp4");
    }

    async void ProgressChange(Progress m)
    {
        // display progress % (0-1)
        Console.WriteLine($"Progress {m.Ratio}");

        //if ffmpeg processing is complete (generate a media URL so that it can be played or alternatively download that file)
        if (m.Ratio == 1)
        {
            //get bytepointer from c wasm to c#
            var res = await ff.ReadFile("output.mp4");


            //generate a url from file bufferPointer
            videoOutputUrl = FFmpegFactory.CreateURLFromBuffer(res, "output.mp4", "video/mp4");

            //Download the file instantly
            FFmpegFactory.DownloadBufferAsFile(res, "output.mp4", "video/mp4");

            StateHasChanged();
        }
    }

    void WriteLogs(Logs m)
    {
        Console.WriteLine(m.Type + " " + m.Message);
    }
}